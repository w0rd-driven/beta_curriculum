# Pokemon API

```elixir
Mix.install([
  {:kino, "~> 0.7.0", override: true},
  {:youtube, github: "brooklinjazz/youtube"},
  {:hidden_cell, github: "brooklinjazz/hidden_cell"},
  {:httpoison, "~> 1.8"},
  {:poison, "~> 5.0"},
  {:req, "~> 0.3.2"}
])
```

## Navigation

[Return Home](../start.livemd)<span style="padding: 0 30px"></span>
[Report An Issue](https://github.com/DockYard-Academy/beta_curriculum/issues/new?assignees=&labels=&template=issue.md&title=)

## Mastery

Mastery assignments are bonus projects designed to incorporate curriculum concepts at an advanced level. You have complete freedom with how you complete mastery assignments, and may change requirements as you see fit. Each mastery assignment serves as an independent project you may choose to include on your portfolio of projects.

## Pokemon API

When we rely on an external API, it's possible for them to change the format of a response, and have that cause issues for our application.

That's why it's often important to translate information from an API into a struct when we retrieve it. This way if the format of the API response changes then we can fix the issue in a single spot where we convert the API response into a struct. We can also keep only the information we want, rather than all of the data returned.

Often, certain APIs will have a language-specific implementation that makes it easier to interact with the API.

You're going to create a `Pokelixir` project which uses the [Pokemon API](https://pokeapi.co/) to return Elixir-friendly `Pokemon` structs.

Create a new `Pokelixir` mix project.

```
mix new pokelixir
```

Ensure you add [HTTPoison](https://github.com/edgurgel/httpoison) and [Poison](https://github.com/devinus/poison) as dependencies.

## Pokemon Structs

A `Pokemon` struct should have the following (required) keys. You do not need to implement data validation.

```mermaid
classDiagram
  class Pokemon {
    id: integer
    name: string
    hp: integer
    attack: integer
    defense: integer
    special_attack: integer
    special_defense: integer
    speed: integer
    weight: integer
    height: integer
    types: list of strings
  }
```

Here's that data represented as a `Pokemon` struct.

<!-- livebook:{"force_markdown":true} -->

```elixir
%Pokemon{
  id: 6,
  name: "charizard",
  hp: 78,
  attack: 84,
  defense: 78,
  special_attack: 109,
  special_defense: 85,
  speed: 100,
  height: 17,
  weight: 905,
  types: ["fire", "flying"]
}
```

```elixir
# From https://thibautbarrere.com/2022/09/09/implementing-a-disk-cache-for-elixir-req
defmodule CustomCache do
  @moduledoc """
  A simple HTTP cache for `req` that do not use headers. 
  If the file is not found on disk, the download will occur,
  otherwise response will be read from disk.
  """
  require Logger

  def attach(%Req.Request{} = request, options \\ []) do
    request
    |> Req.Request.register_options([:custom_cache_dir])
    |> Req.Request.merge_options(options)
    |> Req.Request.append_request_steps(custom_cache: &request_local_cache_step/1)
    |> Req.Request.prepend_response_steps(custom_cache: &response_local_cache_step/1)
  end

  def request_local_cache_step(request) do
    # TODO: handle a form of expiration - for now it is
    # acceptable to wipe out the whole folder manually for me
    # NOTE: race condition here, for parallel queries
    if File.exists?(path = cache_path(request)) do
      # Logger.info("File found in cache (#{path})")
      # a request step can return a {req,resp} tuple,
      # and this will bypass the remaining request steps
      {request, load_cache(path)}
    else
      request
    end
  end

  def response_local_cache_step({request, response}) do
    unless File.exists?(path = cache_path(request)) do
      if response.status == 200 do
        # Logger.info("Saving file to cache (#{path})")
        write_cache(path, response)
      else
        Logger.info("Status is #{response.status}, not saving file to disk")
      end
    end

    {request, response}
  end

  # https://github.com/wojtekmach/req/blob/102b9aa6c6ff66f00403054a0093c4f06f6abc2f/lib/req/steps.ex#L1268
  def cache_path(cache_dir, request = %{method: :get}) do
    cache_key =
      Enum.join(
        [
          request.url.host,
          Atom.to_string(request.method),
          :crypto.hash(:sha256, :erlang.term_to_binary(request.url))
          |> Base.encode16(case: :lower)
        ],
        "-"
      )

    Path.join(cache_dir, cache_key)
  end

  def cache_path(request) do
    cache_path(request.options[:custom_cache_dir], request)
  end

  # https://github.com/wojtekmach/req/blob/102b9aa6c6ff66f00403054a0093c4f06f6abc2f/lib/req/steps.ex#L1288-L1290
  def load_cache(path) do
    path |> File.read!() |> :erlang.binary_to_term()
  end

  # https://github.com/wojtekmach/req/blob/102b9aa6c6ff66f00403054a0093c4f06f6abc2f/lib/req/steps.ex#L1283-L1286
  def write_cache(path, response) do
    File.mkdir_p!(Path.dirname(path))
    File.write!(path, :erlang.term_to_binary(response))
  end
end

defmodule Pokelixir do
  @enforce_keys [
    :id,
    :name,
    :hp,
    :attack,
    :defense,
    :special_attack,
    :special_defense,
    :speed,
    :height,
    :weight,
    :types
  ]
  defstruct @enforce_keys

  @base_url "https://pokeapi.co/api/v2/pokemon"

  def get(name) do
    cache_dir = Path.join(__ENV__.file, "../cache-dir") |> Path.expand()

    req =
      Req.new(url: "#{@base_url}/#{name}", cache: true)
      |> CustomCache.attach(custom_cache_dir: cache_dir)

    Req.get!(req).body
    |> transform_pokemon()
  end

  def all() do
    cache_dir = Path.join(__ENV__.file, "../cache-dir") |> Path.expand()

    req =
      Req.new(url: "#{@base_url}", cache: true)
      |> CustomCache.attach(custom_cache_dir: cache_dir)

    # Cheating to get the first 500 without pagination
    Req.get!(req, params: [limit: 500], cache: true).body
    |> transform_results()
  end

  defp transform_pokemon(json) do
    # We pattern match to get our deeply nested values.
    #   One day I'll figure out a different way to do this.
    #   That's not today apparently.
    # I lied apparently, apparently.
    stats =
      if json["stats"] == nil do
        %{}
      else
        Enum.reduce(json["stats"], %{}, fn stat, accumulator ->
          Map.put(accumulator, stat["stat"]["name"], stat["base_stat"])
        end)
      end

    # IO.inspect(json["stats"], label: "json[stats]")
    # IO.inspect(stats, label: "stats")
    # [
    #   %{
    #     "base_stat" => hp,
    #     "stat" => %{"name" => "hp"}
    #   },
    #   %{
    #     "base_stat" => attack,
    #     "stat" => %{
    #       "name" => "attack"
    #     }
    #   },
    #   %{
    #     "base_stat" => defense,
    #     "stat" => %{
    #       "name" => "defense"
    #     }
    #   },
    #   %{
    #     "base_stat" => special_attack,
    #     "stat" => %{
    #       "name" => "special-attack"
    #     }
    #   },
    #   %{
    #     "base_stat" => special_defense,
    #     "stat" => %{
    #       "name" => "special-defense"
    #     }
    #   },
    #   %{
    #     "base_stat" => speed,
    #     "stat" => %{"name" => "speed"}
    #   }
    # ] = json["stats"]

    types =
      if json["types"] == nil do
        %{}
      else
        Enum.map(json["types"], fn type ->
          type["type"]["name"]
          # %{
          #   "type" => %{"name" => name}
          # } = type
          # name
        end)
      end

    # IO.inspect(types, label: "types")
    %Pokelixir{
      id: json["id"],
      name: json["name"],
      hp: stats["hp"],
      attack: stats["attack"],
      defense: stats["defense"],
      special_attack: stats["special-attack"],
      special_defense: stats["special-defense"],
      speed: stats["speed"],
      height: json["height"],
      weight: json["weight"],
      types: types
    }
  end

  defp transform_results(json) do
    Enum.map(json["results"], fn result ->
      get(result["name"])
    end)
  end
end

# Pokelixir.get("charizard")
# Pokelixir.get("charmander")
Pokelixir.all()
```

## Get A Pokemon

We can request information about Pokemon using the [Pokemon API](https://pokeapi.co/).

You can retrieve information with the following URL where `name` is the name of the pokemon.

```
https://pokeapi.co/api/v2/pokemon/name
```

For example, you can retrieve the stats for `charizard` by making an HTTP GET request to the following URL.

```
https://pokeapi.co/api/v2/pokemon/charizard
```

You should be able to retrieve the data for a pokemon and return it as a `Pokemon` struct.

<!-- livebook:{"force_markdown":true} -->

```elixir
Pokelixir.get("charizard")
```

<details style="background-color: burlywood; padding: 1rem; margin: 1rem 0;">
<summary>Hint</summary>

You can retrieve and decode the response using [HTTPoison](https://hexdocs.pm/httpoison/HTTPoison.html) and [Poison](https://hexdocs.pm/poison/Poison.html).

```elixir
{:ok, response} = HTTPoison.get("https://pokeapi.co/api/v2/pokemon/charizard")
response = Poison.decode!(response.body)
```

</details>

## Get All Pokemon

You can retrieve a list of pokemon using the following URL.

```
https://pokeapi.co/api/v2/pokemon
```

By default, this URL only shows the the first `20` pokemon, and provides a `"next"` URL to retrieve the next `20` pokemon. This is a common [pagination](https://en.wikipedia.org/wiki/Pagination) strategy to avoid loading too much data at once.

<details style="background-color: lightgrey; padding: 1rem; margin: 1rem 0;">
<summary>Response Example</summary>

```javascript
{
  "count": 1154,
  "next": "https://pokeapi.co/api/v2/pokemon?offset=20&limit=20",
  "previous": null,
  "results": [
    {
    "name": "bulbasaur",
    "url": "https://pokeapi.co/api/v2/pokemon/1/"
    },
    {
    "name": "ivysaur",
    "url": "https://pokeapi.co/api/v2/pokemon/2/"
    },
    {
    "name": "venusaur",
    "url": "https://pokeapi.co/api/v2/pokemon/3/"
    },
    {
    "name": "charmander",
    "url": "https://pokeapi.co/api/v2/pokemon/4/"
    },
    {
    "name": "charmeleon",
    "url": "https://pokeapi.co/api/v2/pokemon/5/"
    },
    {
    "name": "charizard",
    "url": "https://pokeapi.co/api/v2/pokemon/6/"
    },
    {
    "name": "squirtle",
    "url": "https://pokeapi.co/api/v2/pokemon/7/"
    },
    {
    "name": "wartortle",
    "url": "https://pokeapi.co/api/v2/pokemon/8/"
    },
    {
    "name": "blastoise",
    "url": "https://pokeapi.co/api/v2/pokemon/9/"
    },
    {
    "name": "caterpie",
    "url": "https://pokeapi.co/api/v2/pokemon/10/"
    },
    {
    "name": "metapod",
    "url": "https://pokeapi.co/api/v2/pokemon/11/"
    },
    {
    "name": "butterfree",
    "url": "https://pokeapi.co/api/v2/pokemon/12/"
    },
    {
    "name": "weedle",
    "url": "https://pokeapi.co/api/v2/pokemon/13/"
    },
    {
    "name": "kakuna",
    "url": "https://pokeapi.co/api/v2/pokemon/14/"
    },
    {
    "name": "beedrill",
    "url": "https://pokeapi.co/api/v2/pokemon/15/"
    },
    {
    "name": "pidgey",
    "url": "https://pokeapi.co/api/v2/pokemon/16/"
    },
    {
    "name": "pidgeotto",
    "url": "https://pokeapi.co/api/v2/pokemon/17/"
    },
    {
    "name": "pidgeot",
    "url": "https://pokeapi.co/api/v2/pokemon/18/"
    },
    {
    "name": "rattata",
    "url": "https://pokeapi.co/api/v2/pokemon/19/"
    },
    {
    "name": "raticate",
    "url": "https://pokeapi.co/api/v2/pokemon/20/"
    }
  ]
}
```

</details>

Each pokemon in the results list also has a URL you can use to get information about each pokemon.

https://pokeapi.co/api/v2/pokemon/6/

You should be able to return a list of `Pokemon` structs for every pokemon.

<!-- livebook:{"force_markdown":true} -->

```elixir
Pokemon.all()
```

<details style="background-color: burlywood; padding: 1rem; margin: 1rem 0;">
<summary>Hint</summary>

You can either recursively retrieve the next `20` pokemon using the `"next"` url, or
you can make a request using the `limit` query parameter with a larger value than the number of pokemon.

```elixir
{:ok, response} = HTTPoison.get("https://pokeapi.co/api/v2/pokemon/?limit=1154")
response = Poison.decode!(response.body)
```

</details>

## GitHub Repository

Connect your `Pokelixir` project to a GitHub repository and create a README to describe the purpose of the project and what you learned building it.

Consider refactoring, adding documentation, and testing if you have not already to make this an even better resume project.

## Further Feature Ideas

This project is designed to be extendable to improve your skills. Here are some examples of how to expand the initial feature set.

* [x] Add a cache which caches each pokemon to retrieved to avoid re-requesting the same data from the API.
* [ ] Add more endpoints from the Pokemon API. see: https://pokeapi.co/docs/v2.
* [ ] Add more information to the `Pokemon` struct to make it more closely represent the data from the Pokemon API.
* [ ] Add documentation + doctests and [publish your project on hex.pm](https://hex.pm/docs/publish)

## Commit Your Progress

Run the following in your command line from the curriculum folder to track and save your progress in a Git commit.
Ensure that you do not already have undesired or unrelated changes by running `git status` or by checking the source control tab in Visual Studio Code.

```
$ git checkout main
$ git checkout -b exercise-pokemon_api
$ git add .
$ git commit -m "finish pokemon api exercise"
$ git push origin exercise-pokemon_api
```

Create a pull request to your forked `main` branch. Please do not create a pull request to the DockYard Academy repository as this will spam our PR tracker.

**DockYard Academy Students Only:**

Notify your teacher by including `@BrooklinJazz` in your PR description to get feedback.

If you are interested in joining the next academy cohort, [sign up here](https://academy.dockyard.com/) to receive more news when it is available.

## Up Next

| Previous                                                             | Next                                         |
| -------------------------------------------------------------------- | -------------------------------------------: |
| [Spoonacular Recipe API](../exercises/spoonacular_recipe_api.livemd) | [Web Servers](../reading/web_servers.livemd) |
